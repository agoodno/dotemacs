#+STARTUP: overview

See [[https://www.gnu.org/software/emacs/manual/elisp.html][GNU Emacs Lisp Reference Manual]]

* General
** Env vars
   #+BEGIN_SRC emacs-lisp
     (defconst system-desc
       (cond
        ((string-equal system-type "darwin") "mac")
        ((string-equal system-type "gnu/linux") "linux")
        ((string-equal system-type "windows-nt") "windows")))

     (setq on_work_laptop (equal (system-name) "MMEM7107.local"))
     (setq on_home_laptop (equal (system-name) "Andrews-MacBook-Pro.local"))

     (setq as_agoodnough (equal user-login-name "agoodnough"))
     (setq as_andrew (equal (user-login-name) "andrew"))

     (setq at_work (and on_work_laptop as_agoodnough))
     (setq at_home (and on_home_laptop as_andrew))
   #+END_SRC
** User settings
   #+BEGIN_SRC emacs-lisp
     (cond (at_work
            (setq user-full-name "Andy Goodnough"
                  user-mail-address "andy.goodnough@wisc.edu"))
           (at_home
            (setq user-full-name "Andrew Goodnough"
                  user-mail-address "agoodno@gmail.com"))
           nil)
   #+END_SRC
** Changes backups to go to a backup directory
   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
   #+END_SRC
** Auto revert all files changed elsewhere
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC
** Setup environment
*** Set path variable
#+BEGIN_SRC emacs-lisp
(setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
#+END_SRC
*** Set pager to cat for shell
#+BEGIN_SRC emacs-lisp
(setenv "PAGER" "/bin/cat")
#+END_SRC
** Setup execution path
*** Add user local binaries
#+BEGIN_SRC emacs-lisp
(setq exec-path (append exec-path '("/usr/local/bin")))
#+END_SRC
*** Add home binaries
#+BEGIN_SRC emacs-lisp
(setq exec-path (append exec-path (list (concat (getenv "HOME") "/bin"))))
#+END_SRC
** Compilation buffer
*** Scroll with output automatically
#+BEGIN_SRC emacs-lisp
  (setq compilation-scroll-output t)
  ;;(setq compilation-scroll-output 'first-error)
#+END_SRC
*** Show on top of current buffer instead of new buffer
#+BEGIN_SRC emacs-lisp
  (add-to-list 'same-window-buffer-names "*compilation*")
#+END_SRC
* Look & Feel
** Turn off startup splash
/Note: *inhibit-startup-message* and *inhibit-splash-screen* are aliases for this variable./
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
#+END_SRC
** Turn off menu
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
#+END_SRC
** Turn off tool-bar
#+BEGIN_SRC emacs-lisp
(when (fboundp 'tool-bar-mode)
  (tool-bar-mode -1))
#+END_SRC
** Turn off scroll-bar
#+BEGIN_SRC emacs-lisp
(when (fboundp 'scroll-bar-mode)
  (scroll-bar-mode -1))
#+END_SRC
** Turn off initial scratch buffer text message
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message nil)
#+END_SRC
** Disable line wrap
#+BEGIN_SRC emacs-lisp
(setq default-truncate-lines t)
#+END_SRC
** Highlight selected regions
#+BEGIN_SRC emacs-lisp
(setq transient-mark-mode t)
#+END_SRC
** Display line and column numbers
#+BEGIN_SRC emacs-lisp
(setq line-number-mode t)
(setq column-number-mode t)
#+END_SRC
** Prompts
#+BEGIN_SRC emacs-lisp
;; "y or n" instead of "yes or no"
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Indenting
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
(setq-default indent-tabs-mode nil)

;; Indent with spaces, never with TABs
(setq-default indent-tabs-mode nil)

;; Sets basic offset
(setq c-basic-offset 2)

;; Indent to 2 spaces
(setq-default tab-width 2)

;; Tabs stop every 2 spaces
(setq-default tab-stop-list (quote (2 4 6 8 10)))
#+END_SRC
** Selection
#+BEGIN_SRC emacs-lisp
(setq x-select-enable-clipboard t
      ;; x-select-enable-primary t ;;causes problems with delete-selection-mode
      save-interprogram-paste-before-kill nil
      apropos-do-all t
      mouse-yank-at-point nil)

;; Paste and backspace operations delete the selection and "pastes over" it
(delete-selection-mode t)
#+END_SRC
** Windowing
#+BEGIN_SRC emacs-lisp
;; Make side by side buffers function the same as the main window
(setq truncate-partial-width-windows nil)

(setq split-width-threshold nil)
#+END_SRC
* Functions
#+BEGIN_SRC emacs-lisp
  (defun untabify-buffer ()
    "Untabify current buffer"
    (interactive)
    (untabify (point-min) (point-max)))

  (defun progmodes-before-save-hook ()
    "Hooks which run on file write for programming modes"
    (require 'whitespace)

    (prog1 nil
      (set-buffer-file-coding-system 'utf-8-unix)
      (untabify-buffer)
      (whitespace-cleanup)))

  (defun progmodes-hooks ()
    "Hooks for programming modes"
    (add-hook 'before-save-hook 'progmodes-before-save-hook))

  (defun shell-dir (name dir)
    "Opens a shell into the specified directory
   ex. (shell-dir "cmd-rails" "/Users/agoodnough/src/rails/")"
   (let ((default-directory dir))
     (shell name)))

  (defun insert-current-date ()
    (interactive)
    (insert (shell-command-to-string "echo -n $(date %Y-%m-%d)")))

  (require 'calendar)
  (defun insdate-insert-current-date (&optional omit-day-of-week-p)
    "Insert today's date using the current locale.
    With a prefix argument, the date is inserted without the day of
    the week."
    (interactive "P*")
    (insert (calendar-date-string (calendar-current-date) nil
                                  omit-day-of-week-p)))

  (defun insert-date (prefix)
    "Insert the current date. With prefix-argument, use ISO format. With
     two prefix arguments, write out the day and month name."
    (interactive "P")
    (let ((format "%Y-%m-%d")
          (system-time-locale "en_US"))
      (insert (format-time-string format))))

  (defun ins-tommorrows-date ()
    (interactive)
    (insert (format-time-string "%A, %B %e, %Y" (time-add (current-time) (seconds-to-time (* 60 (* 60 (* 24))))))))

  ;; (float-time)
  ;; (calendar-date-string (decode-time (seconds-to-time (+ (* 60 (* 60 (* 24))) (float-time (current-time))))))

  ;; (format-time-string "%A, %B %e, %Y" (decode-time (time-add (current-time) (seconds-to-time (* 60 (* 60 (* 24)))))))

  ;; (seconds-to-time (* 60 (* 60 (* 24))))

  ;; (format-time-string "%A, %B %e, %Y" (current-time))
  ;; (format-time-string "%A, %B %e, %Y" (time-add (current-time) (seconds-to-time (* 60 (* 60 (* 24))))))
  ;; (decode-time (seconds-to-time (+ (float-time (current-time)) (* 60 (* 60 (* 24))))))

  (defun back-window ()
    (interactive)
    (other-window -1))

  (defun log-region (&optional arg)
    "Keyboard macro."
    (interactive "p")
    (kmacro-exec-ring-item
     (quote ([134217847 16 5 return 112 117 116 115 32 34 25 61 35 123 25 125 34] 0 "%d")) arg))

  (defun agg-set-background-color-dark ()
    (progn
      ;; (set-face-attribute 'default nil :family "Monaco" :height 106 :weight 'normal)

      ;; reverse-video

      ;; Setting this on the frame-level allows for new frames opened to
      ;; automatically take on the same color scheme
      (add-to-list 'default-frame-alist '(foreground-color . "white"))
      (add-to-list 'default-frame-alist '(background-color . "black"))
      (add-to-list 'default-frame-alist '(cursor-color . "white"))

      ;; Didn't work with multiple frames, but useful for ad-hoc switching
      (set-foreground-color "white")
      (set-background-color "black")

      (set-face-attribute  'mode-line-inactive
                           nil
                           :foreground "gray80"
                           :background "gray25"
                           :box '(:line-width 1 :style released-button))
      (set-face-attribute  'mode-line
                           nil
                           :foreground "gray25"
                           :background "gray80"
                           :box '(:line-width 1 :style released-button))))

  (defun agg-set-background-color-light ()
    (progn
      ;; (set-face-attribute 'default nil :family "Monaco" :height 106 :weight 'normal)

      ;; regular video

      ;; Setting this on the frame-level allows for new frames opened to
      ;; automatically take on the same color scheme
      (add-to-list 'default-frame-alist '(foreground-color . "black"))
      (add-to-list 'default-frame-alist '(background-color . "lightyellow"))
      (add-to-list 'default-frame-alist '(cursor-color . "black"))

      ;; Didn't work with multiple frames, but useful for ad-hoc switching
      (set-foreground-color "black")
      (set-background-color "lightyellow")

      (set-face-attribute  'mode-line
                           nil
                           :foreground "gray80"
                           :background "gray25"
                           :box '(:line-width 1 :style released-button))
      (set-face-attribute  'mode-line-inactive
                           nil
                           :foreground "gray25"
                           :background "gray80"
                           :box '(:line-width 1 :style released-button))))

  (defun agg-toggle-background-color ()
    "Toggle background and foreground colors between light and dark."
    (interactive)
    ;; use a property “state”. Value is t or nil
    (if (get 'agg-toggle-background-color 'state)
        (progn
          (agg-set-background-color-light)
          (put 'agg-toggle-background-color 'state nil))
      (progn
        (agg-set-background-color-dark)
        (put 'agg-toggle-background-color 'state t))))
#+END_SRC
* Bindings
#+BEGIN_SRC emacs-lisp
;; Align your code in a pretty way.
(global-set-key (kbd "C-x \\") 'align-regexp)

;; Completion that uses many different methods to find options.
(global-set-key (kbd "M-/") 'hippie-expand)

;; Perform general cleanup.
(global-set-key (kbd "C-c n") 'cleanup-buffer)

;; Use regex searches by default.
(global-set-key (kbd "C-s") 'isearch-forward-regexp)
(global-set-key (kbd "C-r") 'isearch-backward-regexp)
(global-set-key (kbd "C-M-s") 'isearch-forward)
(global-set-key (kbd "C-M-r") 'isearch-backward)

;; Buffers
(global-set-key (kbd "C-c y") 'bury-buffer)
(global-set-key (kbd "C-c r") 'revert-buffer)
(global-set-key (kbd "M-`") 'file-cache-minibuffer-complete)
; Use ibuffer which is better than switch buffer
(global-set-key (kbd "C-x C-b") 'ibuffer)

;; Insert
(global-set-key "\C-x\M-d" `insdate-insert-current-date)

;; Window switching. (C-x o goes to the next window)
(windmove-default-keybindings) ;; Shift+direction
(global-set-key (kbd "C-x O") (lambda () (interactive) (other-window -1))) ;; back one
(global-set-key (kbd "C-x C-o") (lambda () (interactive) (other-window 2))) ;; forward two

;; Start eshell or switch to it if it's active.
(global-set-key (kbd "C-x m") 'eshell)

;; Start a new eshell even if one is active.
(global-set-key (kbd "C-x M") (lambda () (interactive) (eshell t)))

;; Start a regular shell if you prefer that.
(global-set-key (kbd "C-x M-m") 'shell)

;; If you want to be able to M-x without meta (phones, etc)
(global-set-key (kbd "C-x C-m") 'execute-extended-command)

;; Fetch the contents at a URL, display it raw.
(global-set-key (kbd "C-x C-h") 'view-url)

;; Help should search more than just commands
(global-set-key (kbd "C-h a") 'apropos)

;; Should be able to eval-and-replace anywhere.
(global-set-key (kbd "C-c e") 'eval-and-replace)

;; For debugging Emacs modes
(global-set-key (kbd "C-c p") 'message-point)

;; Comment or uncomment region
(global-set-key (kbd "C-c C-;") 'comment-or-uncomment-region)

;; Activate occur easily inside isearch
(define-key isearch-mode-map (kbd "C-o")
  (lambda () (interactive)
    (let ((case-fold-search isearch-case-fold-search))
      (occur (if isearch-regexp isearch-string (regexp-quote isearch-string))))))

;; Org
(define-key global-map "\C-cl" 'org-store-link)
(define-key global-map "\C-ca" 'org-agenda)

(define-key global-map (kbd "C-M-+") 'text-scale-increase)
(define-key global-map (kbd "C-M-_") 'text-scale-decrease)

                                        ;(global-set-key "\C-q" 'backward-kill-word)

;;Permanently, force TAB to insert just one TAB (in every mode):
(global-set-key (kbd "TAB") 'tab-to-tab-stop)

;;Opens browser to url
(global-set-key (kbd "C-x C-u") 'browse-url)
(global-set-key (kbd "C-c C-o") 'browse-url)

;;Toggles whitespace
(global-set-key (kbd "C-c w") 'whitespace-mode)

;; Launch a new shell. Use "C-u" to be prompted for the shell's name
(global-set-key [f2] 'shell)

;; Refresh file from disk
(global-set-key [f5] 'revert-buffer)

;; Moves current buffer to last buffer
(global-set-key [f6] 'bury-buffer)

;; Moves last buffer to current buffer
(global-set-key [f7] 'unbury-buffer)

;; In shell, moves the prompt to the line of previously executed command
(global-set-key [f8] 'comint-previous-prompt)

(global-set-key [f9] 'undo)

(global-set-key [f11] 'whitespace-mode)

;; Unset F10 for tmux chicanery
;; https://superuser.com/questions/1142577/bind-caps-lock-key-to-tmux-prefix-on-macos-sierra
(global-unset-key [f10])

(global-set-key [f12] 'toggle-truncate-lines)

(global-set-key (kbd "C--") 'back-window)

(global-set-key (kbd "C-=") 'other-window)

(global-set-key (kbd "s-p") 'previous-buffer)

(global-set-key (kbd "s-n") 'next-buffer)

(global-set-key (kbd "C-x C-l") 'log-region)

;; Two approaches are discussed here for local key bindings
;; http://stackoverflow.com/questions/9818307/emacs-mode-specific-custom-key-bindings-local-set-key-vs-define-key

;; This is a general approach to binding a specific key binding to one
;; or more modes. Should be used in this file.
;; (defun my/bindkey-recompile ()
;;   "Bind <F5> to `recompile'."
;;   (local-set-key (kbd "<f5>") 'recompile))
;; (add-hook 'c-mode-common-hook 'my/bindkey-recompile)

;; This is a general approach for binding a specific key binding for
;; use in one mode. Should be used in the package-config/<mode>.el file.
;; (eval-after-load "org-mode"
;;   '(progn
;;      (define-key org-mode-map (kbd "C-c t") 'ins-tommorrows-date)))
;;      (define-key org-mode-map (kbd "C-c d") 'insdate-insert-current-date)
#+END_SRC
* Development
** General
  #+BEGIN_SRC emacs-lisp
    (use-package smartparens
      :ensure t
      :defer t
      :init
      (require 'smartparens-config))
  #+END_SRC
** Data Formats
*** JSON
    #+BEGIN_SRC emacs-lisp
      (use-package json-mode
        :ensure t
        :defer t
        :init (add-hook 'json-mode-hook '(lambda ()
                                           (setq indent-tabs-mode nil)
                                           (setq tab-width 2)
                                           (setq indent-line-function (quote insert-tab))
                                           (local-set-key (kbd "C-c C-f") 'json-pretty-print-buffer))))

      (use-package json-reformat
        :init
        (customize-set-variable 'json-reformat:indent-width 2))
    #+END_SRC
*** XML
    #+BEGIN_SRC emacs-lisp
      (use-package nxml-mode
        :mode "\\.xml\\'"
        :init
        (defun agg/xml-format ()
          "Format an XML buffer with xmllint."
          (interactive)
          (shell-command-on-region (point-min) (point-max)
                                   "xmllint -format -"
                                   (current-buffer) t
                                   "*Xmllint Error Buffer*" t))
        (add-hook 'nxml-mode-hook 'progmodes-hooks)
        :bind (:map nxml-mode-map
                    ("C-c C-l" . agg/xml-format)))

      (use-package auto-complete-nxml
        :ensure t
        :defer t
        :after (auto-complete))
    #+END_SRC
** Languages
*** Clojure
    #+BEGIN_SRC emacs-lisp
      (use-package clojure-mode
        :ensure t
        :defer t
        :after (paredit)
        :init
        (add-hook 'clojure-mode-hook #'smartparens-mode))

      ;; avoid clojure-mode-extra-font-locking if using CIDER

      (use-package cider
        :ensure t
        :defer t
        :init
        (setq clojure-indent-style :always-indent)
        (setq cider-repl-use-pretty-printing t)
        (setq cider-repl-wrap-history t)
        (setq cider-repl-history-size 1000)
        (setq cider-repl-history-file "~/.cider-repl-history.txt"))
    #+END_SRC
*** Java
    #+BEGIN_SRC emacs-lisp
      (add-hook 'java-mode-hook (lambda ()
                                  (setq c-basic-offset 4
                                        tab-width 4)))

      (use-package eclim
        :ensure t
        :defer t
        :init
        (setq eclimd-autostart nil)
        (setq eclim-eclipse-dirs '("/Applications/SpringToolSuite4.app/Contents/Eclipse"))
        (setq eclim-executable "/Applications/SpringToolSuite4.app/Contents/Eclipse/plugins/org.eclim_2.8.0/bin/eclim")
        (setq eclim-auto-save t)
        (setq eclim-use-yasnippet t)
        ;; display compilation error messages in the echo area
        (setq help-at-pt-display-when-idle t)
        (setq help-at-pt-timer-delay 0.1)
        (defun my-java-mode-hook ()
          (eclim-mode t))
        (add-hook 'java-mode-hook 'my-java-mode-hook)
        (add-hook 'java-mode-hook 'progmodes-hooks)
        :config
        (help-at-pt-set-timer))

      (use-package ac-emacs-eclim
        :ensure t
        :defer t
        :after (auto-complete eclim)
        :config
        (ac-emacs-eclim-config))
    #+END_SRC
*** Javascript
    #+BEGIN_SRC emacs-lisp
      (use-package js2-mode
        :ensure t
        :defer t
        :after (smartparens)
        :init
        (customize-set-variable 'js2-basic-offset 2)
        (customize-set-variable 'js2-bounce-indent-p t)
        ;; To install it as your major mode for JavaScript editing:
        (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
        ;; You may also want to hook it in for shell scripts running via node.js:
        ;; (add-to-list 'interpreter-mode-alist '("node" . js2-mode))
        ;; Support for JSX is available via the derived mode `js2-jsx-mode'.  If you
        ;; also want JSX support, use that mode instead:
        (add-to-list 'auto-mode-alist '("\\.jsx?\\'" . js2-jsx-mode))
        (add-to-list 'interpreter-mode-alist '("node" . js2-jsx-mode))
        (add-hook 'js2-mode-hook #'smartparens-mode)
        (add-hook 'js2-mode-hook (lambda () (setq js2-basic-offset 2))))

      (use-package ac-js2
        :ensure t
        :defer t
        :after (auto-complete js2-mode)
        :init (add-hook 'js2-mode-hook 'ac-js2-mode))
    #+END_SRC
*** Ruby
    #+BEGIN_SRC emacs-lisp
   (use-package ruby-mode
     :init
     (add-to-list 'auto-mode-alist '("\\.gemspec$" . ruby-mode))
     (add-to-list 'auto-mode-alist '("\\.rake$" . ruby-mode))
     (add-to-list 'auto-mode-alist '("\\.ru$" . ruby-mode))
     (add-to-list 'auto-mode-alist '("Capfile$" . ruby-mode))
     (add-to-list 'auto-mode-alist '("Gemfile$" . ruby-mode))
     (add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode))
     ;;(add-hook 'ruby-mode-hook #'aggressive-indent-mode)
     (add-hook 'ruby-mode-hook 'progmodes-hooks))

   (use-package inf-ruby
     :ensure t)

   (use-package robe
     :ensure t
     :after (ruby-mode auto-complete)
     :init
     (add-hook 'ruby-mode-hook 'robe-mode)
     (add-hook 'robe-mode-hook 'ac-robe-setup))

   (use-package rvm
     :ensure t
     :init
     (add-hook 'ruby-mode-hook (lambda ()
                                 (rvm-activate-corresponding-ruby)))
     :config
     (rvm-use-default))
    #+END_SRC
* Packages
** aggressive-indent
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :ensure t)
#+END_SRC
** ansi-color
#+BEGIN_SRC emacs-lisp
  (use-package ansi-color
    :ensure t
    :init
    (defun my/ansi-colorize-buffer ()
      (let ((buffer-read-only nil))
        (ansi-color-apply-on-region (point-min) (point-max))))
    (add-hook 'compilation-filter-hook 'my/ansi-colorize-buffer))
#+END_SRC
** auto-complete
#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :ensure t
    :config
    (ac-config-default))
#+END_SRC
** bar-cursor
#+BEGIN_SRC emacs-lisp
  (use-package bar-cursor
    :ensure t
    :init (bar-cursor-mode 1))
#+END_SRC
** browse-url
#+BEGIN_SRC emacs-lisp
  ;; Open links in Chrome on macOS
  ;; (setq gnus-button-url 'browse-url-generic
  ;;       browse-url-generic-program "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"
  ;;       browse-url-browser-function gnus-button-url)

  ;; Open links in Safari
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "open")
#+END_SRC
** company
##+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :init
    (add-hook 'after-init-hook 'global-company-mode))
##+END_SRC
** company-emacs-eclim
##+BEGIN_SRC emacs-lisp
  (use-package company-emacs-eclim
    :ensure t
    :after (company eclim)
    :config
    (company-emacs-eclim-setup))
##+END_SRC
** company-tern
##+BEGIN_SRC emacs-lisp
  (use-package company-tern
    :ensure t
    :defer t
    :after (company tern)
    :init
      (add-hook 'js2-mode-hook (lambda () (tern-mode) (company-mode)))
      (eval-after-load 'company '(push 'company-tern company-backends)))

  (define-key tern-mode-keymap (kbd "M-.") nil)
  (define-key tern-mode-keymap (kbd "M-,") nil)
##+END_SRC
** css
#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'css-indent-offset 2)
#+END_SRC
** ensime
##+BEGIN_SRC emacs-lisp
(use-package ensime
  :ensure t
  :defer t
  ) ;;:pin melpa-stable

(add-hook 'scala-mode-hook 'ensime-scala-mode-hook)

(setq
  ensime-sbt-command "/home/agoodno/src/ccap3/sbt"
  sbt:program-name "/home/agoodno/src/ccap3/sbt"
  ensime-startup-notification nil)
##+END_SRC
** erc
##+BEGIN_SRC emacs-lisp
(defvar freenode-password freenode-agoodno-pass)
(defvar bitlbee-password bitlbee-agoodno-pass)

(setq
  erc-server "irc.wicourts.gov"
  ;; erc-server "chat.freenode.net"
  erc-nick "agoodno"
  erc-prompt (lambda () (concat "[" (buffer-name) "]"))
  ;; erc-prompt-for-nickserv-password nil
  ;; erc-nickserv-passwords `((freenode ("agoodno" . ,freenode-password)))
  erc-email-userid "andrew.goodnough@wicourts.gov"
  ;; erc-email-userid "agoodno@gmail.com"
  erc-user-full-name "Andrew Goodnough"
  ;; erc-autojoin-channels-alist '(("irc.wicourts.gov" "#ccap3" "#cc"))
  erc-autojoin-channels-alist
    '(("freenode.net" "#emacs" "#elasticsearch")
      ("wicourts.gov" "#ccap3" "#cc"))
  ;; erc-join-buffer 'bury
  erc-hide-list '("QUIT" "JOIN" "KICK" "NICK" "MODE")
  erc-echo-notices-in-minibuffer-flag t
  erc-auto-query 'buffer
  erc-save-buffer-on-part nil
  erc-save-queries-on-quit nil
  erc-log-write-after-send t
  erc-log-write-after-insert t
  erc-fill-column 75
  erc-header-line-format nil
  erc-track-exclude-types '("324" "329" "332" "333" "353" "477" "MODE"
                            "JOIN" "PART" "QUIT" "NICK")
  ;; erc-lurker-threshold-time 3600
  ;; erc-track-priority-faces-only t
  ;; erc-autojoin-timing :ident
  ;; erc-flood-protect nil
  ;; erc-server-send-ping-interval 45
  ;; erc-server-send-ping-timeout 180
  ;; erc-server-reconnect-timeout 60
  ;; erc-server-flood-penalty 1000000
  ;; erc-accidental-paste-threshold-seconds 0.5
  erc-fill-function 'erc-fill-static
  erc-fill-static-center 14)

(defun freenode-connect ()
  "Connect to freenode."
  (interactive)
  (erc :server "irc.freenode.net" :port 6667 :nick "agoodno"))

(defun bitlbee-connect ()
  "Connect to bitlbee."
  (interactive)
  (erc :server "127.0.0.1" :port 6667))

(defun wicourts-connect ()
  "Connect to wicourts."
  (interactive)
  (erc :server "irc.wicourts.gov" :port 6667 :nick "agoodno"))

;;(add-hook 'erc-join-hook 'bitlbee-identify)

(defun bitlbee-identify ()
  "If we're on the bitlbee server, send the identify command to the &bitlbee channel."
  (when (and (string= "127.0.0.1" erc-session-server)
             (string= "&bitlbee" (buffer-name)))
    (erc-message "PRIVMSG" (format "%s identify %s"
                                   (erc-default-target)
                                   bitlbee-password))))

;; (delete 'erc-fool-face 'erc-track-faces-priority-list)
;; (delete '(erc-nick-default-face erc-fool-face) 'erc-track-faces-priority-list)

;; (eval-after-load 'erc
;;   '(progn
;;      ;; (when (not (package-installed-p 'erc-hl-nicks))
;;      ;;   (package-install 'erc-hl-nicks))
;;      (require 'erc-spelling)
;;      (require 'erc-services)
;;      (require 'erc-truncate)
;;      ;; (require 'erc-hl-nicks)
;;      (require 'notifications)
;;      (erc-services-mode 1)
;;      (erc-truncate-mode 1)
;;      (setq erc-complete-functions '(erc-pcomplete erc-button-next))
;;      ;; (add-to-list 'erc-modules 'hl-nicks)
;;      (add-to-list 'erc-modules 'spelling)
;;      (set-face-foreground 'erc-input-face "dim gray")
;;      (set-face-foreground 'erc-my-nick-face "blue")
;;      (define-key erc-mode-map (kbd "C-c r") 'pnh-reset-erc-track-mode)
;;      (define-key erc-mode-map (kbd "C-c C-M-SPC") 'erc-track-clear)
;;      (define-key erc-mode-map (kbd "C-u RET") 'browse-last-url-in-brower)))

;; (defun erc-track-clear ()
;;   (interactive)
;;   (setq erc-modified-channels-alist nil))

;; (defun browse-last-url-in-brower ()
;;   (interactive)
;;   (require 'ffap)
;;   (save-excursion
;;     (let ((ffap-url-regexp "\\(https?://\\)."))
;;       (ffap-next-url t t))))

;; (defun pnh-reset-erc-track-mode ()
;;   (interactive)
;;   (setq erc-modified-channels-alist nil)
;;   (erc-modified-channels-update)
;;   (erc-modified-channels-display))

;; (require 'erc-services)
;; (erc-services-mode 1)

;; ;;; Notify me when a keyword is matched (someone wants to reach me)

;; (defvar my-erc-page-message "%s says %s"
;;   "Format of message to display in dialog box")

;; (defvar my-erc-page-nick-alist nil
;;   "Alist of nicks and the last time they tried to trigger a notification")

;; (defvar my-erc-page-timeout 60
;;   "Number of seconds that must elapse between notifications from the same person.")

;; (defun my-erc-page-popup-notification (message)
;;   (when window-system
;;     ;; must set default directory, otherwise start-process is unhappy
;;     ;; when this is something remote or nonexistent
;;     (let ((default-directory "~/"))
;;       ;; 8640000 milliseconds = 1 day
;;       (start-process "page-me" nil "notify-send"
;;                      "-u" "normal" "-t" "8640000" "ERC"
;;                      (format my-erc-page-message (car (split-string nick "!")) message)))))

;; (defun my-erc-page-allowed (nick &optional delay)
;;   "Return non-nil if a notification should be made for NICK.
;; If DELAY is specified, it will be the minimum time in seconds
;; that can occur between two notifications.  The default is
;; `my-erc-page-timeout'."
;;   (unless delay (setq delay my-erc-page-timeout))
;;   (let ((cur-time (time-to-seconds (current-time)))
;;         (cur-assoc (assoc nick my-erc-page-nick-alist))
;;         (last-time))
;;     (if cur-assoc
;;         (progn
;;           (setq last-time (cdr cur-assoc))
;;           (setcdr cur-assoc cur-time)
;;           (> (abs (- cur-time last-time)) delay))
;;       (push (cons nick cur-time) my-erc-page-nick-alist)
;;       t)))

;; (defun my-erc-page-me (match-type nick message)
;;   "Notify the current user when someone sends a message that
;; matches a regexp in `erc-keywords'."
;;   (interactive)
;;   (when (and (eq match-type 'keyword)
;;              ;; I don't want to see anything from the erc server
;;              (null (string-match "\\`\\([sS]erver\\|localhost\\)" nick))
;;              ;; or bots
;;              (null (string-match "\\(bot\\|serv\\)!" nick))
;;              ;; or from those who abuse the system
;;              (my-erc-page-allowed nick))
;;     (my-erc-page-popup-notification message)))
;; (add-hook 'erc-text-matched-hook 'my-erc-page-me)

;; (defun my-erc-page-me-PRIVMSG (proc parsed)
;;   (let ((nick (car (erc-parse-user (erc-response.sender parsed))))
;;         (target (car (erc-response.command-args parsed)))
;;         (msg (erc-response.contents parsed)))
;;     (when (and (erc-current-nick-p target)
;;                (not (erc-is-message-ctcp-and-not-action-p msg))
;;                (my-erc-page-allowed nick))
;;       (my-erc-page-popup-notification msg)
;;       nil)))
;; (add-hook 'erc-server-PRIVMSG-functions 'my-erc-page-me-PRIVMSG)

;; (eval-after-init
;;  '(and
;;                                         ; (add-to-list 'erc-modules 'autoaway)
;;    (add-to-list 'erc-modules 'autojoin)
;;    (add-to-list 'erc-modules 'button)
;;    (add-to-list 'erc-modules 'completion)
;;    (add-to-list 'erc-modules 'fill)
;;    (add-to-list 'erc-modules 'irccontrols)
;;    (add-to-list 'erc-modules 'list)
;;    (add-to-list 'erc-modules 'log)
;;    (add-to-list 'erc-modules 'match)
;;    (add-to-list 'erc-modules 'menu)
;;    (add-to-list 'erc-modules 'move-to-prompt)
;;    (add-to-list 'erc-modules 'netsplit)
;;    (add-to-list 'erc-modules 'networks)
;;    (add-to-list 'erc-modules 'noncommands)
;;    (add-to-list 'erc-modules 'notify)
;;    (add-to-list 'erc-modules 'readonly)
;;    (add-to-list 'erc-modules 'ring)
;;    (add-to-list 'erc-modules 'stamp)
;;    (add-to-list 'erc-modules 'track )
;;    (erc-update-modules)))

;; (customize-set-variable 'erc-server "irc.freenode.net")
;; (customize-set-variable 'erc-port 6667)
;; (customize-set-variable 'erc-nick "agoodno")
##+END_SRC
** erc-hipchatify
##+BEGIN_SRC emacs-lisp
  (use-package erc-hipchatify
    :ensure t
    :defer t
    :init
    (progn
      ;; (customize-set-variable 'shr-use-fonts f)
      ;; (customize-set-variable 'shr-external-browser "")
      (add-to-list 'erc-modules 'hipchatify)
      (erc-update-modules)))
##+END_SRC
** exec-path-from-shell
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize))
#+END_SRC
** f
#+BEGIN_SRC emacs-lisp
  (use-package f
    :ensure t)
#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode)
    :config (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+END_SRC
** flycheck-clojure
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-clojure
    :ensure t
    :defer t
    :init (eval-after-load 'flycheck '(flycheck-clojure-setup)))
#+END_SRC
** html-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'html-mode-hook 'turn-off-auto-fill)
  (add-hook 'html-mode-hook 'progmodes-hooks)
#+END_SRC
** ido
#+BEGIN_SRC emacs-lisp
  (use-package ido
    :ensure t
    :init
    (setq ido-enable-flex-matching t)

    ;; Jump to a definition in the current file. (This is awesome.)
    ;; (global-set-key (kbd "C-x C-i") 'ido-imenu)

    ;; File finding
    ;; (global-set-key (kbd "C-x M-f") 'ido-find-file-other-window)

    (global-set-key (kbd "C-x f") 'recentf-ido-find-file)
    :config
    (ido-mode 1)
    (ido-everywhere 1)
    (icomplete-mode 1))

  (use-package ido-completing-read+
    :ensure t
    :after (ido)
    :init
    (ido-ubiquitous-mode 1))

  (use-package ido-vertical-mode
    :ensure t
    :after (ido)
    :init
    (setq ido-vertical-define-keys 'C-n-and-C-p-only)
    :config
    (ido-vertical-mode 1))

  (use-package flx-ido
    :ensure t
    :config
    (flx-ido-mode))
#+END_SRC
** magit
   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :ensure t
       :init
       (cond (at_work
              (setq magit-projects
                    (quote (
                            ("~/src/alma-invoice-to-wisdm-check-request" . 0)
                            ("~/src/control-repo" . 0)
                            ("~/src/dotemacs" . 0)
                            ("~/src/dotfiles" . 0)
                            ("~/src/gitlabci-maven" . 0)
                            ("~/src/iaapatronextract" . 0)
                            ("~/src/location-manager" . 0)
                            ("~/src/lppi-manager" . 0)
                            ("~/src/lppi-manager-client" . 0)
                            ("~/src/lppi-updater" . 0)
                            ("~/src/patron-bin" . 0)
                            ("~/src/patron-client" . 0)
                            ("~/src/patron-iaa-converter" . 0)
                            ("~/src/patron-iaa-extract" . 0)
                            ("~/src/patron-manager-api" . 0)
                            ("~/src/patron-models" . 0)
                            ("~/src/patron-postprocess" . 0)
                            ("~/src/patron-view" . 0)
                            ("~/src/patron-util" . 0)))))
             (at_home
              (setq magit-projects
                    (quote (
                            ("~/src/dotemacs" . 0)
                            ("~/src/dotfiles" . 0)))))
             (setq magit-projects
                   (quote (
                           ("~/src/dotemacs" . 0)
                           ("~/src/dotfiles" . 0)))))
       (setq magit-completing-read-function 'magit-ido-completing-read)
       (customize-set-variable 'magit-display-buffer-function
         (quote magit-display-buffer-fullframe-status-v1))
       (customize-set-variable 'magit-status-sections-hook
         '(magit-insert-status-headers
           magit-insert-merge-log
           magit-insert-rebase-sequence
           magit-insert-am-sequence
           magit-insert-sequencer-sequence
           magit-insert-bisect-output
           magit-insert-bisect-rest
           magit-insert-unpulled-from-upstream
           magit-insert-unpulled-from-pushremote
           magit-insert-unpushed-to-upstream
           magit-insert-unpushed-to-pushremote
           magit-insert-staged-changes
           magit-insert-unstaged-changes
           magit-insert-untracked-files
           magit-insert-stashes))
       (customize-set-variable 'magit-repolist-columns
         (quote
           (("Name" 40 magit-repolist-column-ident nil)
           ("Path" 99 magit-repolist-column-path))))
       (customize-set-variable 'magit-repository-directories
         magit-projects)
       (global-set-key (kbd "C-c g") 'magit-status)
       (global-set-key (kbd "C-c l") 'magit-list-repositories))
   #+END_SRC
** markdown-mode
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :defer t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "/usr/local/bin/markdown"))

  ;; Every time I save the markdown file, I want to export it to an HTML file for viewing.
  ;;
  ;; This re-binds the normal 'save-buffer' key-chord to call
  ;; 'markdown-export'. It works because 'markdown-export' calls
  ;; 'save-buffer' in addition to exporting to HTML.
  ;; (eval-after-load 'markdown
  ;;   '(progn
  ;;      (define-key markdown-mode-map (kbd "C-x C-s") 'markdown-export)))

  ;;(define-key markdown-mode-map (kbd "C-x C-s") 'markdown-export)
#+END_SRC
** markdown-preview-eww
#+BEGIN_SRC emacs-lisp
  (use-package markdown-preview-eww
    :ensure t
    :defer t)
#+END_SRC
** neotree
#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :ensure t
    :defer t
    :init
    (global-set-key [f8] 'neotree-toggle))
#+END_SRC
** org-mode
#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
  (setq org-log-done 'note)

  ;; #+TODO: TODO(t) STARTED(s) WAITING(w) | DONE(d) CANCELED(c)
  (setq org-todo-keywords
         '((sequence "IDEA" "TODO" "PLANNING" "DESIGNING" "PROGRAMMING" "WAITING" "TESTING" "CHECKLIST" "MR" "APPROVED" "|" "MERGED" "DELEGATED" "DONE" "CANCELED")))
  (setq org-log-done nil)
#+END_SRC
** projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :defer t)
#+END_SRC
** restclient
#+BEGIN_SRC emacs-lisp
(use-package restclient
  :ensure t
  :defer t)
#+END_SRC
** saveplace
#+BEGIN_SRC emacs-lisp
  (setq save-place-file (locate-user-emacs-file "places" ".emacs-places"))

  (save-place-mode 1)
#+END_SRC
** sbt-mode
##+BEGIN_SRC emacs-lisp
  (use-package sbt-mode
    :ensure t
    :defer t
    ) ;;:pin melpa-stable
##+END_SRC
** scala-mode
##+BEGIN_SRC emacs-lisp
  (use-package scala-mode
    :ensure t
    :defer t
    :init (add-to-list 'auto-mode-alist '("\\.sbt$" . scala-mode))
          (add-hook 'scala-mode-hook 'progmodes-hooks)
    :interpreter ("scala" . scala-mode)) ;;  :pin melpa-stable
##+END_SRC
** shell-mode
#+BEGIN_SRC emacs-lisp
  ;;; Fix junk characters in shell-mode
  ;; Add color to a shell running in emacs 'M-x shell'
  ;;; Shell mode
  ;; (setq ansi-color-names-vector ; better contrast colors
  ;;       ["black" "red4" "green4" "yellow4"
  ;;        "blue3" "magenta4" "cyan4" "white"])
  (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)

  ;; Fixes npm commands that attempt to color interactive user prompts
  ;; ...but messes with sbt and awk among others
  ;; (add-to-list
  ;;          'comint-preoutput-filter-functions
  ;;          (lambda (output)
  ;;            (replace-regexp-in-string "\033\\[[0-9]+[A-Z]" "" output)))

  ;; Fixes some bad characters appearing when color prompts are used
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

  ;; Makes the prompt read-only running in emacs 'M-x shell'
  (add-hook 'shell-mode-hook
       '(lambda () (toggle-truncate-lines 1)))
  (setq comint-prompt-read-only t)
#+END_SRC
** smex
#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :init (smex-initialize)
    (global-set-key (kbd "M-x") 'smex)
    (global-set-key (kbd "M-X") 'smex-major-mode-commands)
    (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command))
#+END_SRC
** sql-mode
#+BEGIN_SRC emacs-lisp
  (setq auto-mode-alist (cons '("\\.psql$" . sql-mode) auto-mode-alist))

  (add-hook 'sql-mode-hook 'turn-off-auto-fill)
  (add-hook 'sql-mode-hook 'progmodes-hooks)

  (provide 'agg-sql-mode)
#+END_SRC
** tern
#+BEGIN_SRC emacs-lisp
  ;; (use-package tern
  ;;   :ensure t
  ;;   :defer t
  ;;   :init

  (add-to-list 'load-path "/home/agoodno/src/tern/emacs/")
  (autoload 'tern-mode "tern.el" nil t)

  (add-hook 'js2-mode-hook (lambda () (tern-mode t)))

  (eval-after-load 'tern
     '(progn
        (require 'tern-auto-complete)
        (tern-ac-setup)))

  ;;(define-key tern-mode-keymap (kbd "M-.") nil)
  ;;(define-key tern-mode-keymap (kbd "M-,") nil)
#+END_SRC
** tidy
#+BEGIN_SRC emacs-lisp
    (use-package tidy
      :ensure t
      :defer t
      :init
      (setq tidy-shell-command "/usr/local/bin/tidy")
      (setq tidy-config-file "~/.tidyrc")
      (setq tidy-temp-directory "/tmp"))
#+END_SRC
** tramp
#+BEGIN_SRC emacs-lisp
  (setq tramp-default-method "ssh")

  (defun connect-patproc-test ()
    (interactive)
    (dired "/lcbuser@patproc-test-host.library.wisc.edu:/opt/patproc-test/"))
#+END_SRC
** uniquify
#+BEGIN_SRC emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
#+END_SRC
** yaml-mode
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t
    :defer t)
#+END_SRC
** yari
#+BEGIN_SRC emacs-lisp
  (use-package yari
    :ensure t
    :defer t
    ;; C-h R
    :init (define-key 'help-command "R" 'yari))
#+END_SRC
* Environment
  #+BEGIN_SRC emacs-lisp
    (agg-toggle-background-color)
    (server-start)
  #+END_SRC
